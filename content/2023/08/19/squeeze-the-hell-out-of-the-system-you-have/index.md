---
title: "充分利用现有系统 - Dan Slimmon"
date: 2023-08-19T01:07:51+08:00
updated: 2023-08-19T01:07:51+08:00
taxonomies:
  tags: []
extra:
  source: https://blog.danslimmon.com/2023/08/11/squeeze-the-hell-out-of-the-system-you-have/
  hostname: blog.danslimmon.com
  author: 
  original_title: "Squeeze the hell out of the system you have"
  original_lang: en
---

About a year ago, I raised a red flag with colleagues and managers about Postgres performance. Our database was struggling to keep up with the load generated by our monolithic SaaS application. CPU utilization was riding between 60 and 80%, and at least once it spiked to 100%, causing a brief outage.  

大约一年前，我向同事和经理提出了有关 Postgres 性能的问题。我们的数据库一直在努力跟上我们的单体 SaaS 应用程序所产生的负载。CPU 使用率一直在 60% 到 80% 之间徘徊，至少有一次飙升到 100%，造成了短暂的中断。

Now, we had been kicking the can down the road with respect to Postgres capacity for a long time. When the database looked too busy, we’d replace it with a bigger instance and move on. This saved us a lot of time and allowed us to focus on other things, like building features, which was great.  

在 Postgres 容量方面，我们已经 "踢皮球 "很长时间了。当数据库看起来太忙时，我们会用一个更大的实例替换它，然后继续前进。这为我们节省了大量时间，让我们可以专注于其他事情，比如构建功能，这非常好。

But this time, it wasn’t possible to scale the DB server vertically: we were already on the biggest instance. And we were about to overload that instance.  

但这次无法纵向扩展 DB 服务器：我们已经使用了最大的实例。而且我们的实例即将超载。

Lots of schemes were floated. Foremost among them:  

人们提出了许多计划。其中最重要的是：

-   **Shard writes.** Spin up a cluster of independent databases, and write data to one or the other according to some partitioning strategy.  
    
    分片写入。启动一个独立数据库集群，并根据某种分区策略将数据写入其中一个或另一个。
-   **Do micro-services.** Split up the monolith into multiple interconnected services, each with its own data store that could be scaled on its own terms.  
    
    提供微服务。将单体拆分成多个相互连接的服务，每个服务都有自己的数据存储，可以根据自身条件进行扩展。

Both of these options are cool! A strong case can be made for either one on its merits. With write sharding, we could potentially increase our capacity by 2 or even 3 orders of magnitude. With micro-services, we’d be free to use “the right tool for the job,” picking data stores optimized to the requirements of each service workload. Either branch of the skill tree would offer exciting options for fault tolerance and operational resilience.  

这两种选择都很酷！无论哪种方案，都有充分的理由支持。通过写分片，我们有可能将容量提高 2 个甚至 3 个数量级。有了微服务，我们就可以自由地使用 "适合工作的工具"，根据每个服务工作负载的要求选择优化的数据存储。技能树的任一分支都将为容错和运营弹性提供令人兴奋的选择。

Either way, everyone had to agree: we’d outgrown our old, naïve implementation. Onward and upward! We can do hard things!  

无论如何，每个人都不得不同意：我们已经摆脱了过去天真烂漫的执行方式。前进，向上！我们能做艰难的事情！

In situations like this, presented with a dazzling array of next-generation architecture options that can be built to last us through the decade, it’s easy to forget what our goal was: to get database performance under control.  

在这种情况下，面对令人眼花缭乱的下一代架构选项，很容易忘记我们的目标：控制数据库性能。

## Complexity costs attention. 复杂性会耗费注意力。

Sometimes, leaps in complexity must be made. It’s generally a good problem to have. If enough demand is being placed on your system to render obsolete your existing technology, then even more growth is probably on the horizon! If you can just put in the investment and build the more advanced architecture now, then you’ll be looking at a bright future of unconstrained year-over-year success.  

有时，必须实现复杂性的飞跃。一般来说，这是一个很好的问题。如果对系统的需求足以使现有技术过时，那么更多的增长可能就在眼前！如果您现在就能投入资金，建立更先进的架构，那么您就会看到一个光明的未来，年复一年地取得成功。

But don’t just consider the implementation cost. The real cost of increased complexity – often the much larger cost – is attention.  

但不要只考虑实施成本。复杂性增加的真正成本--往往是更大的成本--是注意力。

If you decide to shard across databases, then not only must you pay the money-, time-, and opportunity cost of building out the new architecture: _you must also take the new complexity into account in every subsequent technical decision_. Want to shard writes? Fine, but this complicates every future decision about backups, monitoring, migrations, the ORM, and network topology (just to name a few). And don’t get me started on micro-services.  

如果您决定跨数据库分片，那么您不仅必须为构建新架构付出金钱、时间和机会成本，还必须在随后的每项技术决策中考虑到新的复杂性。想要分片写入？好吧，但这会使今后关于备份、监控、迁移、ORM 和网络拓扑结构（仅举几例）的所有决策都变得复杂。别让我再提微服务了。

Just think about how massive these costs are. How much feature delivery will have to be delayed or foregone to support the additional architectural complexity?  

试想一下，这些成本是多么庞大。为了支持额外的架构复杂性，需要推迟或放弃多少功能交付？

## Always squeeze first 总是先挤压

We should always put off significant complexity increases as long as possible.  

我们应该尽可能推迟复杂性的大幅增加。

When complexity leaps are on the table, there’s usually also an opportunity to **squeeze** some extra juice out of the system you have. By tweaking the workload, tuning performance, or supplementing the system in some way, you may be able to add months or even years of runway. When viable, these options are always preferable to building out a next-gen system.  

当复杂性发生飞跃时，通常也有机会从现有系统中榨取额外的能量。通过调整工作量、调整性能或以某种方式对系统进行补充，你可能会增加数月甚至数年的运行时间。在可行的情况下，这些方案总是比构建新一代系统更可取。

Let’s return to the example of the overloaded Postgres instance. In that case, what we ended up doing was twofold:  

让我们回到重载 Postgres 实例的例子。在这种情况下，我们最终要做两件事：

1.  Two engineers (me and my colleague Ted – but mostly Ted) spent about 3 months working primarily on database performance issues. There was no silver bullet. We used our telemetry to identify heavy queries, dug into the (Rails) codebase to understand where they were coming from, and optimized or eliminated them. We also tuned a lot of Postgres settings.  
    
    两名工程师（我和我的同事泰德，但主要是泰德）花了大约 3 个月的时间主要研究数据库性能问题。没有什么灵丹妙药。我们使用遥测技术识别重度查询，深入研究（Rails）代码库以了解它们的来源，并优化或消除它们。我们还调整了很多 Postgres 设置。
2.  Two more engineers cut a path through the codebase to run certain expensive read-only queries on a replica DB. This effort bore fruit around the same time as (1), when we offloaded our single most frequent query (a `SELECT` triggered by polling web clients).  
    
    另外两名工程师在代码库中开辟了一条路径，以便在复制数据库上运行某些昂贵的只读查询。这项工作与（1）同时取得了成果，我们卸载了最频繁的单个查询（由轮询网络客户端触发的 `SELECT` ）。

These two efforts together reduced the maximum weekly CPU usage on the database from 90% to 30%.  

这两项工作加在一起，将数据库每周 CPU 的最大使用率从 90% 降至 30%。

Now we can sleep at night. We have a huge amount of room to grow, both in terms of CPU headroom and our ability to shed load from the primary. And furthermore, since our work touched many parts of the codebase and demanded collaboration with lots of different devs, we now have a strong distributed knowledge base about the existing system. We’re well positioned to squeeze it even more if need be.  

现在，我们可以安然入睡了。无论是在 CPU 空间方面，还是在减轻主负载的能力方面，我们都有了巨大的发展空间。此外，由于我们的工作涉及代码库的许多部分，需要与许多不同的开发人员合作，因此我们现在拥有了一个关于现有系统的强大的分布式知识库。如果需要，我们完全有能力对其进行更大的压缩。

## This doesn’t mean complexity is bad  

这并不意味着复杂性就是坏事

Of course, I’m not saying complexity is bad. It’s necessary. Some day we’ll reach a fundamental limit of our database architecture, and before that day arrives, we’ll need to make a jump in complexity.  

当然，我并不是说复杂性不好。它是必要的。总有一天，我们的数据库架构会达到一个基本极限，而在这一天到来之前，我们需要在复杂性上有一个飞跃。

But until then, because we **squeezed first**, we get to keep working with the most boring system possible. This is by far the cheaper and more practical option.  

但在此之前，因为我们先挤出了时间，所以我们可以继续使用最无聊的系统。这是迄今为止最便宜、最实用的选择。
